# First example

#2
#wtf? 2

f? :Function Integer from:
    x? Integer
    y? Integer
as:
    :return x * 2 + y * 3


g? :Function Integer from:
    xxx? Integer Ovalue
    yyy? Integer Ovalue
as:
    :return xxx + yyy


Pair? :Record as:
    first? Integer
    second? Integer

    new? :Initializer as:
        $ first ?= 1
        $ second ?= 2

    meth? :Function Integer as:
        prints("Meth!")
        :return $ first + $ second

    dump? :Function as:
        prints("Pair({x}, {y})" { x: $ first, y: $ second })

    sable? :Implementation Streamifiable

    sable.streamify? :Function from: stream? String Lvalue as:
        "(" sable streamify(stream)
        $ first sable streamify(stream)
        "," sable streamify(stream)
        $ second sable streamify(stream)
        ")" sable streamify(stream)
        
        
make_pair? :Function Pair as:
    p? Pair
    p first = 11
    p second = 22
    :return p


double? :Function (Integer, Integer) as:
    :return (98, 99)

    
print_pair? :Function from:
    p? Pair Ovalue
as:
    prints("A pair of ({x}, {y})" { x: p first, y: p second })


restart? :Function as:
    start  # check predeclarations


nasty? :Function may: { SMALL_ERROR, BIG_ERROR } as:
    :raise `SMALL_ERROR
    
    
XCounter? :Record as:
    current? Integer
    limit? Integer
    
    new? :Function from:
        n? Integer
    as:
        $ current = -1
        $ limit = n
        
    ible? :Implementation Integer Iterator

    ible.next? :Function Integer may: { DONE } as:
        $ current += 1
    
        :if $ current == $ limit then:
            :raise `DONE
        else:
            :return $ current


XStringiterator? :Record as:
    string? String
    index? Integer
    
    new? :Function from:
        s? String
    as:
        $ string = s
        $ index = -1

    ible? :Implementation Character Iterator
    
    ible.next? :Function Character may: { DONE } as:
        $ index += 1
    
        :if $ index == $ string length then:
            :raise `DONE
        else:
            :return $ string[$ index]


Base? :Class as:
    base_value? Integer
    
    base_init? :Initializer as:
        $ base_value ?= 100
        prints("The base is initialized.")
    
    base_method? :Function as:
        prints("The base value is {x}." {x: $ base_value})
        
    ? :Finalizer as:
        prints("The base is finalized.")


Greetable? :Class as:
    base? :Role Base

    init? :Initializer as:
        $ base base_init
        
        $ number ?= 1
        $ name ?= "The Greetable"
        #$ g? `null
        prints("I'm here as {x}." { x: $ name })
        
    greet? :Function as:
        prints("Hello, I'm {me}!" { me: $ name })

    ? :Finalizer as:
        prints("I'm outta here!")

    number? Integer
    name? String
    #g? Greetable


twice? :Function from:
    how? Integer Dvalue
    what? Integer Code
as:
    :try
        sum? what(1) + what(2)
        prints("That was {sum}." {})
    or:
        prints("What failed!")


passthrough? :Function from: what? Integer Code as:
    :try what or:
        prints("Passthrough code is breaking.")
        :yield


test_integers? :Function as:
    printi(f(1, 2))
    
    a? Integer
    a = 2
    b? Integer
    b = 3
    
    :if a == b then: prints("a == b") else: prints("a != b")
    
    :if a < b && a > b then: prints("Huh?") else: prints("Huh.")
    
    c? Integer
    c = Integer :if a == b then: 100 else: 200
    prints("This should be 200: {c}" {})

    d? 6u8
    d += 7u8
    d = d * d
    
    :if d then: prints("Yes, d is nonzero.")

    Myint? :Integer bytes: 8 is_unsigned: `false
    myvar? Myint


test_strings? :Function as:
    a? 1
    prints("Hello!")

    s? "Szia!"
    prints(s)

    #c = 4
    #printu8(s[c])
    
    prints(s + s)

    s chars[3] = s[4]
    prints(s)

    s chars[3] = `unicode 592
    prints(s)

    prints("s[3] is now '{c}'" { c: s[3] })

    z? String ""
    prints(z || "Ez tök 대박")
    
    :if z == String `empty then: prints("z is empty")
    
    z = s
    printb(z encode_utf8)

    :if z == `empty then: prints("ERROR z is still empty")

    :if z == "Szia!" then: prints("ERROR z is Szia!")

    :if z == "Sziɐ!" then: prints("z is Sziɐ!")

    #(1, 2) + (3, 4)

    :if a == a then:
        zz? "ZZ"
        prints(zz)
    
    prints((xx? "hi") + xx)
    
    prints(333 stringify)

    prints("XXXXX{a}YYYYY" {})

    prints("{six} and {seven}" { six: 6, seven: 7 })

    prints("aba and ab compares as: {c}" { c: "aba" <=> "ab" })
    prints("aba is less than ab: {c}" { c: "aba" < "ab" })

    chars? "BFADCE"
    prints("Unsorted: {chars}" {})
    chars chars sort
    prints("Sorted:   {chars}" {})


test_enums? :Function as:
    Myenum? :Enumeration
        FOO, BAR, BAZ

    fbb? Myenum `BAR
    :if fbb == `FOO then: prints("fbb is FOO") else: prints("fbb is not FOO")

    prints("fbb is actually {f}!" { f: fbb })


test_ovalues? :Function as:
    printi(g(100, 100))
    printi(g(100))
    printi(g)


test_records? :Function as:
    p? Pair

    p first = 123
    p second = 456
    print_pair(p)
    printi(p meth)

    p = make_pair
    printi(p second)
    
    q? Pair
    q first = 123
    q second = 456
    :if p == q then: prints("Equal tuples.") else: prints("Inequal tuples.")
    
    print_pair
    
    p dump dump
    
    r? Pair `new
    r dump
    
    s? Pair { second: 222 }
    s dump

    q first = 11
    prints("{p} and {q} compares as {c}" { p: p, q: q, c: p <=> q })


test_multis? :Function as:
    x1? Integer
    x2? Integer
    (x1, x2) = double
    prints("Double returned {x1} and {x2}." {})
    (x1, x2) = (100, 101)
    prints("Double assigned {x1} and {x2}." {})
    x3? Integer
    x3 = double
    prints("Scalarized to {x3}" {})


test_controls? :Function as:
    :repeat i? 0 on: i < 3 by: i += 1 do:
        prints("something")

    prints("Done.")

    MyTree? :Treenumeration
        ONE { TEN, ELEVEN, TWELVE },
        TWO { TWENTY },
        THREE,
        FOUR

    my_tree? MyTree `TWENTY
    prints("This tree is {my_tree}." {})
    
    :switch my_tree do:
        :is ~TWO then:
            prints("Two-something.")

        :is `TWENTY then:
            prints("Exactly twenty.")

        :is ~TWENTY then:
            prints("Twenty.")
            :yield
            
        prints("Not any.")
        :yield

    :try
        nasty
    or:
        :is ~BIG_ERROR then:
            prints("This was a big error!")
            
        :is ~SMALL_ERROR then:
            prints("This was a small error!")
            :yield
            
        prints("Too bad!")

    :for 3 countup each: c? do:
        prints("Counting up: {c}" {})

    :for 3 countdown each: c? do:
        prints("Counting down: {c}" {})

    :for "Abc" each: c? do:
        prints("Iterating elems: {c}" {})

    :for "Abc" indexes each: i? do:
        prints("Iterating indexes: {i}" {})
        
    :for "Abc" items each: it? do:
        prints("Iterating items: {i} => {e}" {i: it index, e: it value})

    ait? "Abc" elements
    :for ait each: c? do:
        prints("Iterating elems again: {c}" {})
    
    x3? Integer            
    x3 = :lol:
        prints("Now yielding.")
        :lol 33
        prints("Don't print this!")
        44
        
    prints("Let's hope that {x3} == 33." {})
    
    x3 = :switch 1 do: :yield 44
    
    prints("Let's hope that {x3} == 44." {})
    
    x3 = :try 55

    prints("Let's hope that {x3} == 55." {})
    
    x4? Integer :try 66

    prints("Let's hope that {x4} == 66." {})

    :if Boolean `false > `true then:
        prints("Fake news!")

    :if !! Boolean `true then:
        prints("Faker news!")

    twice(how: h? what: (prints("You want {h}?" {}), h * 1000))

    :eval:
        passthrough(what: (:eval, 0))
        prints("This shouldn't be printed!")

    :hihi:if `true then: 1 else:if `false then: 0

    :if `true then:
        last? 0
        prints("Returning.")
        :return
    
    prints("Don't print this!")


test_arrays? :Function as:
    strings? String Array Ref `empty
    prints("Empty array length: {x}" { x: strings length })

    ss? String Array Ref { "foo", "bar" }
    prints("Nonempty array has {x} and {y}" { x: ss[0], y: ss[1] })

    ss_popped1? :try ss pop
    prints("Array popped {ss_popped1}" {})
    ss_popped2? String :try ss pop
    prints("Array popped {ss_popped2}" {})

    st? String Stack Ref `empty
    :try st push("foo")
    :try st push("bar")
    :try st push("baz")
    prints("Pushed stack length: {x}" { x: st length })
    prints("Pushed stack has 2. elem: {x}" { x: st[2] })
    
    :for st each: x? do:
        prints("Stack has: {x}" {})
    
    baz? String :try st pop
    :try st pop
    :try st pop
    prints("Popped baz as {baz}" {})
    prints("Popped stack length: {x}" { x: st length })


test_circularrays? :Function as:
    ca? String Circularray Ref { "foo", "bar", "baz", "xxx" }
    :try ca pop
    prints("Have a Circularray of {x}" { x: ca length })
    ca1? String :try ca shift
    prints("Shifted {x}, remained {y} and {z}." { x: ca1, y: ca[0], z: ca[1] })
    :try ca unshift "foo"
    :try ca unshift "foofoo"
    prints("Unshifted {x} and {y} to {z} and {w}" { x: ca[0], y: ca[1], z: ca[2], w: ca[3] })
    prints("Circularray length is {l}" { l: ca length })

    :for ca items each: it? do:
        prints("Circularray items: {x} => {y}" {x: it index, y: it value})

    qu? String Queue Ref { "A", "B", "C", "D", "E", "F", "G", "H" }
    :try qu shift
    :try qu push "I"  # folds
    :try qu push "J"  # grows
    :for qu items each: it? do:
        prints("Queue items: {x} => {y}" { x: it index, y: it value })

    qv? String Queue Ref { "A", "B", "C", "D", "E", "F", "G", "H" }
    :try qv pop
    :try qv unshift "@"  # folds
    :try qv unshift "@@" # grows
    :for qv items each: it? do:
        prints("Queue items: {x} => {y}" { x: it index, y: it value })


test_rbtrees? :Function as:
    rb? String Rbtree Ref `reserved 8
    
    :try
        rb add "A"
        rb add "C"
        rb add "E"
        rb add "D"
        rb add "B"
        
    prints("After adding A, length is {l}" { l: rb length })
    
    :for rb elements_by_age each: e? do:
        prints("Rbtree element by age: {e}" {})

    :for rb elements_by_order each: e? do:
        prints("Rbtree element by order: {e}" {})

    :if rb has "A" then:
        prints("Rb has A, good.")
        
    :if !! rb has "Z" then:
        prints("Rb has no Z, good")
    
    :try
        rb remove "A"
        rb remove "B"
        rb remove "C"
        rb remove "D"
        rb remove "E"
        
    prints("After removing all, length is {l}" { l: rb length })
    
    :if !! rb has "A" then:
        prints("Rb has no A, good")

    st? String Set Ref { "A", "B" }
    
    :try
        st add "C"
        st add "D"
    
    :for st elements_by_age each: e? do:
        prints("Set element: {e}" {})

    mp? (String, String) Map Ref {{ "A", "a" }, { "B", "b" }}
    :try
        mp add("C", "c")
        mp add("D", "d")
    :try
        mp remove("C")
    prints("Map length is {x}" {x: mp length})
    
    :for mp tree elements_by_order each: iv? do:
        prints("Map element: {x} => {y}" {x: iv index, y: iv value})
    
    prints("Map element at A is: {x}" {x: mp["A"]})


test_options? :Function as:
    op1? String Option `some "XYZ"
    prints("This option is: {op1}" {})
    
    op2? String Option `none
    prints("That option is: {op2}" {})
    
    op2 = op1
    prints("And became: {op2}" {})
    prints("So they're now equal: {x}" {x: op1 == op2})
    #prints("Is it none? {x} Is it some? {y}" {x: op1 is none, y: op1 is some})
    
    :is op1s? op1 ~some then:
        prints("It contained some {op1s}." {})
    else:
        prints("IT CONTAINED NONE!")

    :is op1 ~none then:
        prints("IT CONTAINED NONE!")
    else:
        prints("It contained some.")
            

test_classes? :Function as:
    gr? Greetable Ref `init
    gr greet
    
    gr2? gr
    gr2 = gr
    
    wgr? :weak gr
    wgr greet
    
    wgr = gr
    
    gr base base_method


start? :Function as:
    test_integers
    test_strings
    test_enums
    test_ovalues
    test_records
    test_multis
    test_controls
    test_arrays
    test_circularrays
    test_rbtrees
    test_options
    test_classes
    
    prints("Done.")
