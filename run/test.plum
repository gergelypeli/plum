# First example

#2
#wtf? 2

f? :Function Integer from:
    x? Integer
    y? Integer
as:
    :return x * 2 + y * 3


g? :Function Integer from:
    xxx? Integer Ovalue
    yyy? Integer Ovalue
as:
    :return xxx + yyy


Pair? :Record as:
    first? Integer
    second? Integer

    new? :Initializer as:
        $ first? 1
        $ second? 2

    meth? :Function Integer as:
        prints("Meth!")
        :return $ first + $ second

    dump? :Function as:
        prints("Pair({x}, {y})" { x: $ first, y: $ second })

    sable? :Implementation Streamifiable

    sable.streamify? :Function from: stream? String Lvalue as:
        "(" sable streamify(stream)
        $ first sable streamify(stream)
        "," sable streamify(stream)
        $ second sable streamify(stream)
        ")" sable streamify(stream)
        
        
make_pair? :Function Pair as:
    p? Pair
    p first = 11
    p second = 22
    :return p


double? :Function (Integer, Integer) as:
    :return (98, 99)

    
print_pair? :Function from:
    p? Pair Ovalue
as:
    prints("A pair of ({x}, {y})" { x: p first, y: p second })


restart? :Function as:
    start  # check predeclarations


nasty? :Function may: { BIG_ERROR, SMALL_ERROR } as:
    :raise `SMALL_ERROR
    
    
XCounter? :Record as:
    current? Integer
    limit? Integer
    
    new? :Function from:
        n? Integer
    as:
        $ current = -1
        $ limit = n
        
    ible? :Implementation Integer Iterator

    ible.next? :Function Integer may: { DONE } as:
        $ current += 1
    
        :if $ current == $ limit then:
            :raise `DONE
        else:
            :return $ current


XStringiterator? :Record as:
    string? String
    index? Integer
    
    new? :Function from:
        s? String
    as:
        $ string = s
        $ index = -1

    ible? :Implementation Character Iterator
    
    ible.next? :Function Character may: { DONE } as:
        $ index += 1
    
        :if $ index == $ string length then:
            :raise `DONE
        else:
            :return $ string[$ index]


Greetable? :Class as:
    init? :Initializer as:
        $ number? 1
        $ name? "XXX"
        $ g? `null
        prints("I'm here as {x}." { x: $ name })
        
    greet? :Function as:
        prints("Hello, I'm {me}!" { me: $ name })

    number? Integer
    name? String
    g? Greetable


start? :Function as:
    print(f(1, 2))
    
    a? Integer
    a = 2
    b? Integer
    b = 3
    
    :if a == b then: prints("a == b") else: prints("a != b")
    
    :if a < b && a > b then: prints("Huh?") else: prints("Huh.")
    
    c? Integer
    c = Integer :if a == b then: 100 else: 200
    prints("This should be 200: {c}" {})
    
    d? 6u8
    d += 7u8
    d = d * d
    
    :if d then: prints("Yes, d is nonzero.")

    prints("Hello!")

    s? "Szia!"
    prints(s)
    
    #c = 4
    #printu8(s[c])
    
    prints(s + s)

    s chars[3] = s[4]
    prints(s)

    s chars[3] = `unicode 592
    prints(s)

    prints("s[3] is now '{c}'" { c: s[3] })

    z? String
    prints(z || "Ez tök 대박")
    
    :if z == String `null then: prints("z is null")
    
    z = s
    printb(z encode_utf8)

    :if z == `null then: prints("ERROR z is still null")

    :if z == "Szia!" then: prints("ERROR z is Szia!")

    :if z == "Sziɐ!" then: prints("z is Sziɐ!")

    #(1, 2) + (3, 4)

    :if a == a then:
        zz? "ZZ"
        prints(zz)
    
    prints((xx? "hi") + xx)
    
    prints(333 stringify)

    prints("XXXXX{a}YYYYY" {})

    prints("{six} and {seven}" { six: 6, seven: 7 })

    Myenum? :Enumeration
        FOO, BAR, BAZ

    fbb? Myenum `BAR
    :if fbb == `FOO then: prints("fbb is FOO") else: prints("fbb is not FOO")

    prints("fbb is actually {f}!" { f: fbb })

    Myint? :Integer bytes: 8 is_unsigned: `false
    myvar? Myint

    print(g(100, 100))
    print(g(100))
    print(g)

    p? Pair

    p first = 123
    p second = 456
    print_pair(p)
    print(p meth)

    p = make_pair
    print(p second)
    
    q? Pair
    q first = 123
    q second = 456
    :if p == q then: prints("Equal tuples.") else: prints("Inequal tuples.")
    
    print_pair
    
    p dump dump
    
    r? Pair `new
    r dump
    
    s? Pair { second: 222 }
    s dump

    q first = 11
    prints("{p} and {q} compares as {c}" { p: p, q: q, c: p <=> q })

    prints("aba and ab compares as: {c}" { c: "aba" <=> "ab" })
    prints("aba is less than ab: {c}" { c: "aba" < "ab" })

    x1? Integer
    x2? Integer
    (x1, x2) = double
    prints("Double returned {x1} and {x2}." {})
    (x1, x2) = (100, 101)
    prints("Double assigned {x1} and {x2}." {})
    x3? Integer
    x3 = double
    prints("Scalarized to {x3}" {})

    :repeat i? 0 on: i < 3 by: i += 1 do:
        prints("something")

    prints("Done.")

    MyTree? :Treenumeration
        ONE { TEN, ELEVEN, TWELVE },
        TWO { TWENTY },
        THREE,
        FOUR

    my_tree? MyTree `TWENTY
    prints("This tree is {my_tree}." {})
    
    :switch my_tree do:
        :when `TWO then:
            prints("Two-something.")

        :when `TWENTY then:
            prints("Twenty.")
            :yield
            
        prints("Not any.")
        :yield

    :try
        nasty
    or:
        :when `BIG_ERROR then:
            prints("This was a big error!")
            
        :when `SMALL_ERROR then:
            prints("This was a small error!")
            :yield
            
        prints("Too bad!")

    :for 3 countup each: c? do:
        prints("Counting up: {c}" {})

    :for 3 countdown each: c? do:
        prints("Counting down: {c}" {})

    :for "Abc" each: c? do:
        prints("Iterating elems: {c}" {})

    :for "Abc" indexes each: i? do:
        prints("Iterating indexes: {i}" {})
        
    :for "Abc" items each: it? do:
        prints("Iterating items: {i} => {e}" {i: it index, e: it value})
        
    x3 = :lol:
        prints("Now yielding.")
        :lol 33
        prints("Don't print this!")
        44
        
    prints("Let's hope that {x3} == 33." {})
    
    x3 = :switch 1 do: :yield 44
    
    prints("Let's hope that {x3} == 44." {})
    
    x3 = :try 55

    prints("Let's hope that {x3} == 55." {})
    
    x4? Integer :try 66

    prints("Let's hope that {x4} == 66." {})

    :if Boolean `false > `true then:
        prints("Fake news!")

    :if ! Boolean `true then:
        prints("Faker news!")
        
    chars? "BFADCE"
    prints("Unsorted: {chars}" {})
    chars chars sort
    prints("Sorted:   {chars}" {})

    strings? String Array `empty
    prints("Empty array length: {x}" { x: strings length })

    ss? String Array { "foo", "bar" }
    prints("Nonempty array has {x} and {y}" { x: ss[0], y: ss[1] })

    st? String Stack `empty
    st push("foo")
    st push("bar")
    st push("baz")
    prints("Pushed stack length: {x}" { x: st length })
    prints("Pushed stack has 2. elem: {x}" { x: st[2] })
    
    :for st each: x? do:
        prints("Stack has: {x}" {})
    
    baz? st pop
    st pop
    st pop
    prints("Popped baz as {baz}" {})
    prints("Popped stack length: {x}" { x: st length })

    #gr? Greetable { 789, "not me, I'm you" }
    #gr greet
    gr? Greetable `init
    gr greet
    
    :if `true then:
        last? 0
        prints("Exiting.")
        :return
    
    :hihi:if `true then: 1 else:if `false then: 0
    
    prints("Don't print this!")
    
    :return
