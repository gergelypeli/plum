# First example

#2
#wtf? 2

f? :Function Integer from:
    x? Integer
    y? Integer
as:
    :return x * 2 + y * 3


g? :Function Integer from:
    xxx? Integer Ovalue
    yyy? Integer Ovalue
as:
    :return xxx + yyy


Pair? :Record
    first? Integer
    second? Integer

    new? :Function as:
        $ first = 1
        $ second = 2

    meth? :Function Integer as:
        prints("Meth!")
        :return $ first + $ second

    dump? :Function as:
        prints("Pair({x}, {y})" { x: $ first, y: $ second })
        
        
make_pair? :Function Pair as:
    p? Pair
    p first = 11
    p second = 22
    :return p


double? :Function (Integer, Integer) as:
    :return (98, 99)

    
print_pair? :Function from:
    p? Pair Ovalue
as:
    prints("A pair of ({x}, {y})" { x: p first, y: p second })


restart? :Function as:
    start  # check predeclarations


nasty? :Function may: { BIG_ERROR, SMALL_ERROR } as:
    :raise `SMALL_ERROR
    
    
Counter? :Record
    current? Integer
    limit? Integer
    
    new? :Function from:
        n? Integer
    as:
        $ current = -1
        $ limit = n
        
    ible? :Implementation Integer Iterator

    ible.next? :Function Integer may: { DONE } as:
        $ current += 1
    
        :if $ current == $ limit then:
            :raise `DONE
        else:
            :return $ current


Stringiterator? :Record
    string? Character Array
    index? Integer
    
    new? :Function from:
        s? Character Array
    as:
        $ string = s
        $ index = -1

    ible? :Implementation Character Iterator
    
    ible.next? :Function Character may: { DONE } as:
        $ index += 1
    
        :if $ index == $ string length then:
            :raise `DONE
        else:
            :return $ string[$ index]


Greetable? :Class
    greet? :Function as:
        prints("Greetings!")

    g? Greetable
    

Dude? :Record
    g? Greetable Role


start? :Function as:
    print(f(1, 2))
    
    a? Integer
    a = 2
    b? Integer
    b = 3
    
    :if a == b then: prints("a == b") else: prints("a != b")
    
    :if a < b && a > b then: prints("Huh?") else: prints("Huh.")
    
    c? Integer
    c = :if a == b then: 100 else: 200
    prints("This should be 200: {c}" {})
    
    d? 6u8
    d += 7u8
    d = d * d
    
    :if d then: prints("Yes, d is nonzero.")

    prints("Hello!")

    s? "Szia!"
    prints(s)
    
    #c = 4
    #printu8(s[c])
    
    prints(s + s)

    s[3] = s[4]
    prints(s)

    s[3] = `unicode 592
    prints(s)

    prints("s[3] is now '{c}'" { c: s[3] })

    z? Character Array
    prints(z || "Ez tök 대박")
    
    :if z == Character Array Reference `null then: prints("z is null")
    
    z = s
    printb(z encode_utf8)

    :if z == `null then: prints("z is still null")

    #(1, 2) + (3, 4)

    :if a == a then:
        zz? "ZZ"
        prints(zz)
    
    prints((xx? "hi") + xx)
    
    prints(333 stringify)

    prints("XXXXX{a}YYYYY" {})

    prints("{six} and {seven}" { six: 6, seven: 7 })

    Myenum? :Enumeration
        FOO, BAR, BAZ

    fbb? Myenum `BAR
    :if fbb == `FOO then: prints("fbb is FOO") else: prints("fbb is not FOO")

    prints("fbb is actually {f}!" { f: fbb })

    Myint? :Integer bytes: 8 is_unsigned: `false
    myvar? Myint

    print(g(100, 100))
    print(g(100))
    print(g)

    p? Pair

    p first = 123
    p second = 456
    print_pair(p)
    print(p meth)

    print(make_pair second)
    
    q? Pair
    q first = 123
    q second = 456
    :if p == q then: prints("Equal tuples.") else: prints("Inequal tuples.")
    
    print_pair
    
    p dump dump
    
    r? Pair `new
    r dump
    
    s? Pair { second: 222 }
    s dump

    x1? Integer
    x2? Integer
    (x1, x2) = double
    prints("Double returned {x1} and {x2}." {})
    (x1, x2) = (100, 101)
    prints("Double assigned {x1} and {x2}." {})
    x3? Integer
    x3 = double
    prints("Scalarized to {x3}" {})

    :repeat i? 0 on: i < 5 by: i += 1 do:
        prints("something")

    prints("Done.")

    MyTree? :Treenumeration
        ONE { TEN, ELEVEN, TWELVE },
        TWO { TWENTY },
        THREE,
        FOUR

    my_tree? MyTree `TWENTY
    prints("This tree is {my_tree}." {})
    
    :switch my_tree do:
        :when `TWO then:
            prints("Two-something.")

        :when `TWENTY then:
            prints("Twenty.")
            :yield
            
        prints("Not any.")
        :yield

    :try
        nasty
    or:
        :when `BIG_ERROR then:
            prints("This was a big error!")
            
        :when `SMALL_ERROR then:
            prints("This was a small error!")
            :yield
            
        prints("Too bad!")

    :for Counter `new 7 each: c? do:
        prints("Counting: {c}" {})

    :for Stringiterator `new "Abcdef" each: c? do:
        prints("Iterating: {c}" {})

    x3 = :lol:
        prints("Now yielding.")
        :lol 33
        prints("Don't print this!")
        44
        
    prints("Let's hope that {x3} == 33." {})
    
    x3 = :switch 1 do: :yield 44
    
    prints("Let's hope that {x3} == 44." {})
    
    x3 = :try 55

    prints("Let's hope that {x3} == 55." {})
    
    x4? Integer :try 66

    prints("Let's hope that {x4} == 66." {})

    dude? Dude
    dude g greet

    :if `true then:
        last? 0
        prints("Exiting.")
        :return
    
    :hihi:if `true then: 1 else:if `false then: 0
    
    prints("Don't print this!")
    
    :return
